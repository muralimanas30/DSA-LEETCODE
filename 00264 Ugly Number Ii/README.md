# 00264 - Ugly Number Ii
    
**Language:** Java  
**Runtime:** 48 ms (Beats 31.35% of users)  
**Memory:** 44.6 MB (Beats 27.47% of users)  

# 📝 **LeetCode Problem**
| 🔢 Problem Number | 📌 Title | 🔗 Link |
|------------------|--------------------------|--------------------------|
| 264 | UGLY NUMBER II | [LeetCode Problem](https://leetcode.com/problems/ugly-number-ii/) |

---

## 💡 **Problem Explanation**

An **ugly number** is a positive integer whose prime factors are limited to `2`, `3`, and `5`. The sequence starts with `1` and continues with numbers formed by multiplying previous ugly numbers by these factors.

The goal is to find the **n-th** ugly number in this sequence.

> **For example:** The first 10 ugly numbers are `1, 2, 3, 4, 5, 6, 8, 9, 10, 12`.
> If `n = 10`, the output should be `12`.

### Sample I/O
- **Input**: `n = 10`
- **Output**: `12`

- **Input**: `n = 1`
- **Output**: `1`

---

## 📊 **Algorithm**

The core idea is to generate ugly numbers in sorted order and pick the n-th one. A **Min-Heap** is the perfect data structure for this, as it always gives us the smallest element efficiently. We also use a **Set** to avoid adding duplicate ugly numbers to our heap.

-   1️⃣ **Initialization**:
    -   Create a `minHeap` (PriorityQueue) to store ugly number candidates.
    -   Create a `seen` set (HashSet) to track numbers already added to the heap, preventing duplicates.
    -   Add the first ugly number, `1L`, to both the `minHeap` and the `seen` set.

-   2️⃣ **Iterative Generation**:
    -   Loop `n` times to find the n-th ugly number.
    -   In each iteration, extract the smallest number from the heap using `minHeap.poll()`. Let's call this `uglyNumber`. This is the next number in our sorted ugly number sequence.

-   3️⃣ **Expand and Add**:
    -   For the extracted `uglyNumber`, generate its potential children by multiplying it by the factors `2`, `3`, and `5`.
    -   For each new candidate (`next = uglyNumber * factor`):
        -   Check if this candidate is in the `seen` set.
        -   If it's **not seen**, add it to both the `minHeap` and the `seen` set. This ensures we only process each unique ugly number once.

-   4️⃣ **Result**:
    -   After `n` iterations, the last `uglyNumber` we polled from the heap is our answer. Cast it to `int` and return.

---

## 🔥 **Code Implementation**

```java
import java.util.PriorityQueue;
import java.util.HashSet;
import java.util.Set;

class Solution {
    public int nthUglyNumber(int n) {
        // A min-heap to store the ugly numbers we've found so far, always giving us the smallest.
        PriorityQueue<Long> minHeap = new PriorityQueue<>();
        
        // A set to keep track of ugly numbers we've already added to the heap to avoid duplicates.
        Set<Long> seen = new HashSet<>();
        
        // The prime factors that define ugly numbers.
        long[] factors = {2, 3, 5};

        // Start with the first ugly number, 1.
        minHeap.add(1L);
        seen.add(1L);

        // This will hold the ugly number we extract from the heap in each iteration.
        long uglyNumber = 1L;

        // Loop n times to find the n-th ugly number.
        for (int i = 0; i < n; i++) {
            // Get the smallest ugly number from the heap.
            uglyNumber = minHeap.poll();

            // Generate the next set of ugly numbers by multiplying with the factors.
            for (long factor : factors) {
                long next = uglyNumber * factor;
                // If we haven't seen this number before, add it to the heap and the set.
                // The `seen.add(next)` returns true if the element was successfully added (i.e., not a duplicate).
                if (seen.add(next)) {
                    minHeap.add(next);
                }
            }
        }

        // After n iterations, uglyNumber holds the n-th ugly number.
        return (int) uglyNumber;  
    }
}
```

---

## 📊 **ASCII Representation**

The process can be visualized as a tree where each node is an ugly number, and its children are generated by multiplying it by `2`, `3`, and `5`. The Min-Heap helps us explore this tree level by level in a sorted manner.

```ascii
         (Poll 1)
           /|\
          / | \
         2  3  5       <-- Heap: [2, 3, 5]

         (Poll 2)
         /  |  \
        4   6  10      <-- Add to heap. Heap becomes: [3, 4, 5, 6, 10]

         (Poll 3)
         /  |  \
        6*  9  15      <-- Add 9, 15. (*6 is duplicate). Heap: [4, 5, 6, 9, 10, 15]

         ... and so on
```

---

## 📊 **TABLE Representation**

Let's trace the execution for `n = 7`. The goal is to find the 7th ugly number.

| Iteration (i) | Polled `uglyNumber` | Heap State Before Poll | New Candidates (x2, x3, x5) | Heap State After Add | `seen` Set |
|:-------------:|:-------------------:|:-----------------------|:-----------------------------|:----------------------|:------------|
| 0 | - | `[1]` | - | `[1]` | `{1}` |
| 1 | `1` | `[1]` | `2`, `3`, `5` | `[2, 3, 5]` | `{1, 2, 3, 5}` |
| 2 | `2` | `[2, 3, 5]` | `4`, `6`, `10` | `[3, 4, 5, 6, 10]` | `{..., 4, 6, 10}` |
| 3 | `3` | `[3, 4, 5, 6, 10]` | `6`(dup), `9`, `15` | `[4, 5, 6, 9, 10, 15]` | `{..., 9, 15}` |
| 4 | `4` | `[4, 5, 6, 9, 10, 15]` | `8`, `12`, `20` | `[5, 6, 8, 9, 10, 12, 15, 20]`| `{..., 8, 12, 20}`|
| 5 | `5` | `[5, 6, ...]` | `10`(dup), `15`(dup), `25`| `[6, 8, 9, 10, 12, 15, 20, 25]`| `{..., 25}` |
| 6 | `6` | `[6, 8, ...]` | `12`(dup), `18`, `30` | `[8, 9, 10, 12, 15, 18, 20, 25, 30]`| `{..., 18, 30}` |
| 7 | `8` | `[8, 9, ...]` | ... | ... | ... |

After the 7th poll (at `i=6`), the `uglyNumber` is **8**. So, the 7th ugly number is 8.

---

## 🚀 **Time & Space Complexity**

-   **Time Complexity**: **O(n log n)**
    -   The main loop runs `n` times to find the n-th ugly number.
    -   Inside the loop, we perform one `poll()` operation and up to three `add()` operations on the min-heap.
    -   Both `poll()` and `add()` on a heap of size `k` take `O(log k)` time.
    -   The size of the heap can grow up to approximately `2n` in this specific problem structure, but it's bounded by `O(n)`.
    -   Therefore, each iteration takes `O(log n)` time, leading to a total time complexity of **O(n log n)**.

-   **Space Complexity**: **O(n)**
    -   The space is dominated by the `minHeap` and the `seen` set.
    -   In the worst case, both data structures will store a number of elements proportional to `n`.
    -   Thus, the space complexity is **O(n)**.
    